var async = require('async'),
    TokenStream = require('./TokenStream'),
    directoryUtils = require('./directory-utils'),
    fs = require('fs'),
    path = require('path');

var findJS = function (path, callback) {
    directoryUtils.walkFilter(path, function (file) {
        return /.*\.js$/i.test(file);
    }, callback);
};

function parseFiles(paths, callback) {
    async.map(paths, function (path, callback) {
        var readStream = null,
            tokenStream = null,
            result = {
                require: [],
                provide: []
            };

        if (Array.isArray(path)) {
            parseFiles(path, callback);
        } else {
            readStream = fs.createReadStream(path, {
                flags: 'r'
            });

            tokenStream = new TokenStream();
            tokenStream.addRule(/^goog\.require\s*\(\s*[\'\"]([^\)]+)[\'\"]\s*\)/gm, 'require');
            tokenStream.addRule(/^goog\.provide\s*\(\s*[\'\"]([^\)]+)[\'\"]\s*\)/gm, 'provide');
            tokenStream.addRule(/^var goog = goog \|\| \{\};/gm, 'base');
            tokenStream.on('token', function (name, matches) {
                if (name === 'base') {
                    result.base = true;
                } else {
                    result[name].push(matches[0]);
                }
            });
            tokenStream.on('end', function () {
                result.path = path;
                callback(null, result);
            });
            readStream.pipe(tokenStream);
        }
    }, callback);
}

function relativePath(from, to) {
  return directoryUtils.relative(path.dirname(from) + '/', to);
}

function calcdeps(options) {
  var inputs = options.input,
      paths = options.path,
      excludes = options.exclude,
      deps = options.dep,
      output_mode = options.output_mode,
      output_file = options.output_file;

  if (output_mode === 'deps') {
    async.map([
        paths,
        deps
    ], function (item, callback) {
        // Find all JavaScript files
        async.concat(item, findJS, callback);
    }, function (err, results) {
        if (err) {
            console.error(err);
        } else {
            var paths = results[0],
                deps = results[1];

            // Excludes files
            paths.filter(function (path) {
                return excludes.indexOf(path) === -1;
            });

            // Parse all files for their `provide` and `require` statements
            async.concat([
                paths,
                deps
            ], parseFiles, function (err, results) {
                if (err) {
                  console.error(err);
                } else {
                  // Find the first file that is recognized as Closure base.js
                  async.detect(results, function (result, callback) {
                    callback(!!result.base);
                  }, function (base) {
                    var outputStream = null;

                    if (base) {
                      if (output_file) {
                        outputStream = fs.createWriteStream(output_file);
                      } else {
                        outputStream = process.stdout;
                      }

                      outputStream.write('// This file was autogenerated by calcdeps.js\n');
                      results.forEach(function (result) {
                        if (!result.base) {
                          outputStream.write('goog.addDependency("' + relativePath(base.path, result.path) + '", ' + JSON.stringify(result.provide) + ', ' + JSON.stringify(result.require) + ');\n');
                        }
                      });
                      outputStream.end();
                    } else {
                      console.error('Did not find Google Closure base.js');
                    }
                  });
                }
            });
        }
    });
  } else if (output_mode === 'script') {

  } else {
    input.filter(function (input) {
      return excludes.indexOf(input) !== -1;
    });
  }
}

module.exports = calcdeps;
